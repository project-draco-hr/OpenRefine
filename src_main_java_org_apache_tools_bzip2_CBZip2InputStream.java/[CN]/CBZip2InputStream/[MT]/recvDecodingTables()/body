{
  char len[][]=new char[N_GROUPS][MAX_ALPHA_SIZE];
  int i, j, t, nGroups, nSelectors, alphaSize;
  int minLen, maxLen;
  boolean[] inUse16=new boolean[16];
  for (i=0; i < 16; i++) {
    if (bsR(1) == 1) {
      inUse16[i]=true;
    }
 else {
      inUse16[i]=false;
    }
  }
  for (i=0; i < 256; i++) {
    inUse[i]=false;
  }
  for (i=0; i < 16; i++) {
    if (inUse16[i]) {
      for (j=0; j < 16; j++) {
        if (bsR(1) == 1) {
          inUse[i * 16 + j]=true;
        }
      }
    }
  }
  makeMaps();
  alphaSize=nInUse + 2;
  nGroups=bsR(3);
  nSelectors=bsR(15);
  for (i=0; i < nSelectors; i++) {
    j=0;
    while (bsR(1) == 1) {
      j++;
    }
    selectorMtf[i]=(char)j;
  }
{
    char[] pos=new char[N_GROUPS];
    char tmp, v;
    for (v=0; v < nGroups; v++) {
      pos[v]=v;
    }
    for (i=0; i < nSelectors; i++) {
      v=selectorMtf[i];
      tmp=pos[v];
      while (v > 0) {
        pos[v]=pos[v - 1];
        v--;
      }
      pos[0]=tmp;
      selector[i]=tmp;
    }
  }
  for (t=0; t < nGroups; t++) {
    int curr=bsR(5);
    for (i=0; i < alphaSize; i++) {
      while (bsR(1) == 1) {
        if (bsR(1) == 0) {
          curr++;
        }
 else {
          curr--;
        }
      }
      len[t][i]=(char)curr;
    }
  }
  for (t=0; t < nGroups; t++) {
    minLen=32;
    maxLen=0;
    for (i=0; i < alphaSize; i++) {
      if (len[t][i] > maxLen) {
        maxLen=len[t][i];
      }
      if (len[t][i] < minLen) {
        minLen=len[t][i];
      }
    }
    hbCreateDecodeTables(limit[t],base[t],perm[t],len[t],minLen,maxLen,alphaSize);
    minLens[t]=minLen;
  }
}
