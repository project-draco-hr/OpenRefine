{
  int cores=Runtime.getRuntime().availableProcessors();
  int size=blocks.size();
  int range=size / cores + 1;
  List<Map<Serializable,Set<Serializable>>> cluster_maps=new ArrayList<Map<Serializable,Set<Serializable>>>(cores);
  List<BlockEvaluator> evaluators=new ArrayList<BlockEvaluator>(cores);
  for (int i=0; i < cores; i++) {
    int range_start=range * i;
    int range_end=range * (i + 1);
    if (range_end > size)     range_end=size;
    evaluators.add(new BlockEvaluator(new ArrayList<Set<String>>(blocks.values()),radius,range_start,range_end));
  }
  try {
    List<Future<Map<Serializable,Set<Serializable>>>> futures=executor.invokeAll(evaluators);
    for (    Future<Map<Serializable,Set<Serializable>>> future : futures) {
      cluster_maps.add(future.get());
    }
  }
 catch (  InterruptedException e1) {
    e1.printStackTrace();
  }
catch (  ExecutionException e) {
    e.printStackTrace();
  }
  Set<Set<Serializable>> clusters=new HashSet<Set<Serializable>>();
  for (  Map<Serializable,Set<Serializable>> cluster_map : cluster_maps) {
    for (    Entry<Serializable,Set<Serializable>> e : cluster_map.entrySet()) {
      Set<Serializable> v=e.getValue();
      if (v.size() > 1) {
        clusters.add(v);
      }
    }
  }
  List<Set<Serializable>> sorted_clusters=new ArrayList<Set<Serializable>>(clusters);
  Collections.sort(sorted_clusters,new SizeComparator());
  return sorted_clusters;
}
