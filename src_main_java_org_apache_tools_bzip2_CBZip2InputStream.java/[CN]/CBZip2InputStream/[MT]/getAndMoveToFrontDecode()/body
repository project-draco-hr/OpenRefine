{
  char[] yy=new char[256];
  int i, j, nextSym, limitLast;
  int EOB, groupNo, groupPos;
  limitLast=baseBlockSize * blockSize100k;
  origPtr=bsGetIntVS(24);
  recvDecodingTables();
  EOB=nInUse + 1;
  groupNo=-1;
  groupPos=0;
  for (i=0; i <= 255; i++) {
    unzftab[i]=0;
  }
  for (i=0; i <= 255; i++) {
    yy[i]=(char)i;
  }
  last=-1;
{
    int zt, zn, zvec, zj;
    if (groupPos == 0) {
      groupNo++;
      groupPos=G_SIZE;
    }
    groupPos--;
    zt=selector[groupNo];
    zn=minLens[zt];
    zvec=bsR(zn);
    while (zvec > limit[zt][zn]) {
      zn++;
{
{
          while (bsLive < 1) {
            int zzi;
            char thech=0;
            try {
              thech=(char)bsStream.read();
            }
 catch (            IOException e) {
              compressedStreamEOF();
            }
            if (thech == -1) {
              compressedStreamEOF();
            }
            zzi=thech;
            bsBuff=(bsBuff << 8) | (zzi & 0xff);
            bsLive+=8;
          }
        }
        zj=(bsBuff >> (bsLive - 1)) & 1;
        bsLive--;
      }
      zvec=(zvec << 1) | zj;
    }
    nextSym=perm[zt][zvec - base[zt][zn]];
  }
  while (true) {
    if (nextSym == EOB) {
      break;
    }
    if (nextSym == RUNA || nextSym == RUNB) {
      char ch;
      int s=-1;
      int N=1;
      do {
        if (nextSym == RUNA) {
          s=s + (0 + 1) * N;
        }
 else         if (nextSym == RUNB) {
          s=s + (1 + 1) * N;
        }
        N=N * 2;
{
          int zt, zn, zvec, zj;
          if (groupPos == 0) {
            groupNo++;
            groupPos=G_SIZE;
          }
          groupPos--;
          zt=selector[groupNo];
          zn=minLens[zt];
          zvec=bsR(zn);
          while (zvec > limit[zt][zn]) {
            zn++;
{
{
                while (bsLive < 1) {
                  int zzi;
                  char thech=0;
                  try {
                    thech=(char)bsStream.read();
                  }
 catch (                  IOException e) {
                    compressedStreamEOF();
                  }
                  if (thech == -1) {
                    compressedStreamEOF();
                  }
                  zzi=thech;
                  bsBuff=(bsBuff << 8) | (zzi & 0xff);
                  bsLive+=8;
                }
              }
              zj=(bsBuff >> (bsLive - 1)) & 1;
              bsLive--;
            }
            zvec=(zvec << 1) | zj;
          }
          nextSym=perm[zt][zvec - base[zt][zn]];
        }
      }
 while (nextSym == RUNA || nextSym == RUNB);
      s++;
      ch=seqToUnseq[yy[0]];
      unzftab[ch]+=s;
      while (s > 0) {
        last++;
        ll8[last]=ch;
        s--;
      }
      if (last >= limitLast) {
        blockOverrun();
      }
      continue;
    }
 else {
      char tmp;
      last++;
      if (last >= limitLast) {
        blockOverrun();
      }
      tmp=yy[nextSym - 1];
      unzftab[seqToUnseq[tmp]]++;
      ll8[last]=seqToUnseq[tmp];
      j=nextSym - 1;
      for (; j > 3; j-=4) {
        yy[j]=yy[j - 1];
        yy[j - 1]=yy[j - 2];
        yy[j - 2]=yy[j - 3];
        yy[j - 3]=yy[j - 4];
      }
      for (; j > 0; j--) {
        yy[j]=yy[j - 1];
      }
      yy[0]=tmp;
{
        int zt, zn, zvec, zj;
        if (groupPos == 0) {
          groupNo++;
          groupPos=G_SIZE;
        }
        groupPos--;
        zt=selector[groupNo];
        zn=minLens[zt];
        zvec=bsR(zn);
        while (zvec > limit[zt][zn]) {
          zn++;
{
{
              while (bsLive < 1) {
                int zzi;
                char thech=0;
                try {
                  thech=(char)bsStream.read();
                }
 catch (                IOException e) {
                  compressedStreamEOF();
                }
                zzi=thech;
                bsBuff=(bsBuff << 8) | (zzi & 0xff);
                bsLive+=8;
              }
            }
            zj=(bsBuff >> (bsLive - 1)) & 1;
            bsLive--;
          }
          zvec=(zvec << 1) | zj;
        }
        nextSym=perm[zt][zvec - base[zt][zn]];
      }
      continue;
    }
  }
}
