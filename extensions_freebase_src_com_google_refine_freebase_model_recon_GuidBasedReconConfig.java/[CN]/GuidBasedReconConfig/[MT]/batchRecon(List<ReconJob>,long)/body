{
  List<Recon> recons=new ArrayList<Recon>(jobs.size());
  Map<String,Recon> guidToRecon=new HashMap<String,Recon>();
  try {
    String query=null;
{
      StringWriter stringWriter=new StringWriter();
      JSONWriter jsonWriter=new JSONWriter(stringWriter);
      jsonWriter.array();
      jsonWriter.object();
      jsonWriter.key("id");
      jsonWriter.value(null);
      jsonWriter.key("name");
      jsonWriter.value(null);
      jsonWriter.key("guid");
      jsonWriter.value(null);
      jsonWriter.key("type");
      jsonWriter.array();
      jsonWriter.endArray();
      jsonWriter.key("guid|=");
      jsonWriter.array();
      for (      ReconJob job : jobs) {
        jsonWriter.value(((GuidBasedReconJob)job).guid);
      }
      jsonWriter.endArray();
      jsonWriter.endObject();
      jsonWriter.endArray();
      query=stringWriter.toString();
    }
    StringBuffer sb=new StringBuffer(1024);
    sb.append(getMqlreadService());
    sb.append("&query=");
    sb.append(ParsingUtilities.encode(query));
    URL url=new URL(sb.toString());
    URLConnection connection=url.openConnection();
    connection.setConnectTimeout(5000);
    connection.connect();
    InputStream is=connection.getInputStream();
    try {
      String s=ParsingUtilities.inputStreamToString(is);
      JSONObject o=ParsingUtilities.evaluateJsonStringToObject(s);
      if (o.has("result")) {
        JSONArray results=o.getJSONArray("result");
        int count=results.length();
        for (int i=0; i < count; i++) {
          JSONObject result=results.getJSONObject(i);
          String guid=result.getString("guid");
          JSONArray types=result.getJSONArray("type");
          String[] typeIDs=new String[types.length()];
          for (int j=0; j < typeIDs.length; j++) {
            typeIDs[j]=types.getString(j);
          }
          ReconCandidate candidate=new ReconCandidate(result.getString("id"),result.getString("name"),typeIDs,100);
          Recon recon=Recon.makeFreebaseRecon(historyEntryID);
          recon.addCandidate(candidate);
          recon.service="mql";
          recon.judgment=Judgment.Matched;
          recon.judgmentAction="auto";
          recon.match=candidate;
          recon.matchRank=0;
          guidToRecon.put(guid,recon);
        }
      }
    }
  finally {
      is.close();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  for (  ReconJob job : jobs) {
    String guid=((GuidBasedReconJob)job).guid;
    Recon recon=guidToRecon.get(guid);
    if (recon == null) {
      recon=createNoMatchRecon(historyEntryID);
    }
    recons.add(recon);
  }
  return recons;
}
