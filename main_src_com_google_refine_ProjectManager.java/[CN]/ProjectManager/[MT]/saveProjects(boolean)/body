{
  List<SaveRecord> records=new ArrayList<SaveRecord>();
  Date startTimeOfSave=new Date();
synchronized (this) {
    for (    long id : _projectsMetadata.keySet()) {
      ProjectMetadata metadata=getProjectMetadata(id);
      Project project=_projects.get(id);
      if (project != null) {
        boolean hasUnsavedChanges=metadata.getModified().getTime() >= project.getLastSave().getTime();
        if (hasUnsavedChanges) {
          long msecsOverdue=startTimeOfSave.getTime() - project.getLastSave().getTime();
          records.add(new SaveRecord(project,msecsOverdue));
        }
 else         if (!project.getProcessManager().hasPending() && startTimeOfSave.getTime() - project.getLastSave().getTime() > s_projectFlushDelay) {
          _projects.remove(id).dispose();
        }
      }
    }
  }
  if (records.size() > 0) {
    Collections.sort(records,new Comparator<SaveRecord>(){
      @Override public int compare(      SaveRecord o1,      SaveRecord o2){
        if (o1.overdue < o2.overdue) {
          return 1;
        }
 else         if (o1.overdue > o2.overdue) {
          return -1;
        }
 else {
          return 0;
        }
      }
    }
);
    logger.info(allModified ? "Saving all modified projects ..." : "Saving some modified projects ...");
    for (int i=0; i < records.size() && (allModified || (new Date().getTime() - startTimeOfSave.getTime() < s_quickSaveTimeout)); i++) {
      try {
        saveProject(records.get(i).project);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
}
