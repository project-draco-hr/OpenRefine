{
  List<Group> keyedGroups=new ArrayList<Group>();
  addRootKeyedGroup(keyedGroups);
  for (  ColumnGroup group : columnModel.columnGroups) {
    if (group.keyColumnIndex >= 0) {
      Group keyedGroup=new Group();
      keyedGroup.keyCellIndex=columnModel.columns.get(group.keyColumnIndex).getCellIndex();
      keyedGroup.cellIndices=new int[group.columnSpan - 1];
      int c=0;
      for (int i=0; i < group.columnSpan; i++) {
        int columnIndex=group.startColumnIndex + i;
        if (columnIndex != group.keyColumnIndex) {
          int cellIndex=columnModel.columns.get(columnIndex).getCellIndex();
          keyedGroup.cellIndices[c++]=cellIndex;
        }
      }
      keyedGroups.add(keyedGroup);
    }
  }
  Collections.sort(keyedGroups,new Comparator<Group>(){
    public int compare(    Group o1,    Group o2){
      return o2.cellIndices.length - o1.cellIndices.length;
    }
  }
);
  int[] lastNonBlankRowsByGroup=new int[keyedGroups.size()];
  for (int i=0; i < lastNonBlankRowsByGroup.length; i++) {
    lastNonBlankRowsByGroup[i]=-1;
  }
  int rowCount=rows.size();
  int groupCount=keyedGroups.size();
  int recordIndex=0;
  for (int r=0; r < rowCount; r++) {
    Row row=rows.get(r);
    row.contextRows=null;
    row.contextRowSlots=null;
    row.contextCellSlots=null;
    for (int g=0; g < groupCount; g++) {
      Group group=keyedGroups.get(g);
      if (!ExpressionUtils.isNonBlankData(row.getCellValue(group.keyCellIndex))) {
        int contextRowIndex=lastNonBlankRowsByGroup[g];
        if (contextRowIndex >= 0) {
          for (          int dependentCellIndex : group.cellIndices) {
            if (ExpressionUtils.isNonBlankData(row.getCellValue(dependentCellIndex))) {
              setRowDependency(this,row,dependentCellIndex,contextRowIndex,group.keyCellIndex);
            }
          }
        }
      }
 else {
        lastNonBlankRowsByGroup[g]=r;
      }
    }
    if (row.contextRowSlots != null && row.contextRowSlots.length > 0) {
      row.recordIndex=-1;
      row.contextRows=new ArrayList<Integer>();
      for (      int index : row.contextRowSlots) {
        if (index >= 0) {
          row.contextRows.add(index);
        }
      }
      Collections.sort(row.contextRows);
      columnModel._hasDependentRows=true;
    }
 else {
      row.recordIndex=recordIndex++;
    }
  }
}
