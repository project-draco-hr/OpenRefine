{
  Properties bindings=ExpressionUtils.createBindings(project);
  _min=Double.POSITIVE_INFINITY;
  _max=Double.NEGATIVE_INFINITY;
  List<Double> allValues=new ArrayList<Double>();
  for (int i=0; i < project.rows.size(); i++) {
    Row row=project.rows.get(i);
    Cell cell=row.getCell(cellIndex);
    ExpressionUtils.bind(bindings,row,i,columnName,cell);
    Object value=eval.evaluate(bindings);
    boolean rowHasError=false;
    boolean rowHasNonNumeric=false;
    boolean rowHasNumeric=false;
    boolean rowHasBlank=false;
    if (ExpressionUtils.isError(value)) {
      rowHasError=true;
    }
 else     if (ExpressionUtils.isNonBlankData(value)) {
      if (value.getClass().isArray()) {
        Object[] a=(Object[])value;
        for (        Object v : a) {
          _totalValueCount++;
          if (ExpressionUtils.isError(v)) {
            rowHasError=true;
          }
 else           if (ExpressionUtils.isNonBlankData(v)) {
            if (v instanceof Number) {
              rowHasNumeric=true;
              processValue(((Number)v).doubleValue(),allValues);
            }
 else {
              rowHasNonNumeric=true;
            }
          }
 else {
            rowHasBlank=true;
          }
        }
      }
 else       if (value instanceof Collection<?>) {
        for (        Object v : ExpressionUtils.toObjectCollection(value)) {
          _totalValueCount++;
          if (ExpressionUtils.isError(v)) {
            rowHasError=true;
          }
 else           if (ExpressionUtils.isNonBlankData(v)) {
            if (v instanceof Number) {
              rowHasNumeric=true;
              processValue(((Number)v).doubleValue(),allValues);
            }
 else {
              rowHasNonNumeric=true;
            }
          }
 else {
            rowHasBlank=true;
          }
        }
      }
 else {
        _totalValueCount++;
        if (value instanceof Number) {
          rowHasNumeric=true;
          processValue(((Number)value).doubleValue(),allValues);
        }
 else {
          rowHasNonNumeric=true;
        }
      }
    }
 else {
      rowHasBlank=true;
    }
    if (rowHasError) {
      _errorRowCount++;
    }
    if (rowHasBlank) {
      _blankRowCount++;
    }
    if (rowHasNumeric) {
      _numericRowCount++;
    }
    if (rowHasNonNumeric) {
      _nonNumericRowCount++;
    }
  }
  _numbericValueCount=allValues.size();
  if (_min >= _max) {
    _step=1;
    _min=Math.min(_min,_max);
    _max=_step;
    _bins=new int[1];
    return;
  }
  double diff=_max - _min;
  _step=1;
  if (diff > 10) {
    while (_step * 100 < diff) {
      _step*=10;
    }
  }
 else {
    while (_step * 100 > diff) {
      _step/=10;
    }
  }
  double originalMax=_max;
  _min=(Math.floor(_min / _step) * _step);
  _max=(Math.ceil(_max / _step) * _step);
  double binCount=(_max - _min) / _step;
  if (binCount > 100) {
    _step*=2;
    binCount=(binCount + 1) / 2;
  }
  if (_max <= originalMax) {
    _max+=_step;
    binCount++;
  }
  _bins=new int[(int)Math.round(binCount)];
  for (  double d : allValues) {
    int bin=(int)Math.floor((d - _min) / _step);
    _bins[bin]++;
  }
}
