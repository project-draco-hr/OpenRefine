{
  Map<String,TypeGroup> map=new HashMap<String,TypeGroup>();
  int cellIndex=column.getCellIndex();
  List<String> samples=new ArrayList<String>(s_sampleSize);
  Set<String> sampleSet=new HashSet<String>();
  for (  Row row : project.rows) {
    Object value=row.getCellValue(cellIndex);
    if (ExpressionUtils.isNonBlankData(value)) {
      String s=value.toString().trim();
      if (!sampleSet.contains(s)) {
        samples.add(s);
        sampleSet.add(s);
        if (samples.size() >= s_sampleSize) {
          break;
        }
      }
    }
  }
  try {
    StringWriter stringWriter=new StringWriter();
    JSONWriter jsonWriter=new JSONWriter(stringWriter);
    jsonWriter.object();
    for (int i=0; i < samples.size(); i++) {
      jsonWriter.key("q" + i + ":search");
      jsonWriter.object();
      jsonWriter.key("query");
      jsonWriter.value(samples.get(i));
      jsonWriter.key("limit");
      jsonWriter.value(3);
      jsonWriter.endObject();
    }
    jsonWriter.endObject();
    StringBuffer sb=new StringBuffer();
    sb.append("http://api.freebase.com/api/service/search?queries=");
    sb.append(ParsingUtilities.encode(stringWriter.toString()));
    URL url=new URL(sb.toString());
    URLConnection connection=url.openConnection();
    connection.setConnectTimeout(5000);
    connection.connect();
    InputStream is=connection.getInputStream();
    try {
      String s=ParsingUtilities.inputStreamToString(is);
      JSONObject o=ParsingUtilities.evaluateJsonStringToObject(s);
      for (int i=0; i < samples.size(); i++) {
        String key="q" + i + ":search";
        if (!o.has(key)) {
          continue;
        }
        JSONObject o2=o.getJSONObject(key);
        if (!(o2.has("result"))) {
          continue;
        }
        JSONArray results=o2.getJSONArray("result");
        int count=results.length();
        for (int j=0; j < count; j++) {
          JSONObject result=results.getJSONObject(j);
          double score=1.0 / (1 + j);
          JSONArray types=result.getJSONArray("type");
          int typeCount=types.length();
          for (int t=0; t < typeCount; t++) {
            JSONObject type=types.getJSONObject(t);
            String id=type.getString("id");
            if (id.equals("/common/topic") || id.equals("/base/ontologies/ontology_instance") || (id.startsWith("/base/") && id.endsWith("/topic"))|| id.startsWith("/user/")|| id.startsWith("/freebase/")) {
              continue;
            }
            if (map.containsKey(id)) {
              TypeGroup tg=map.get(id);
              tg.score+=score;
              tg.count++;
            }
 else {
              map.put(id,new TypeGroup(id,type.getString("name"),score));
            }
          }
        }
      }
    }
  finally {
      is.close();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  List<TypeGroup> types=new ArrayList<TypeGroup>(map.values());
  Collections.sort(types,new Comparator<TypeGroup>(){
    public int compare(    TypeGroup o1,    TypeGroup o2){
      int c=Math.min(s_sampleSize,o2.count) - Math.min(s_sampleSize,o1.count);
      if (c != 0) {
        return c;
      }
      return (int)Math.signum(o2.score / o2.count - o1.score / o1.count);
    }
  }
);
  return types;
}
